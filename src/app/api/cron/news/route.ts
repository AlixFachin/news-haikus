import { NextResponse, NextRequest } from "next/server";
import { getNews } from "@/utils/news";
import { generateOneHaikuFromDate } from "@/utils/main";
import dayjs from "dayjs";

// Forcing the route to be revalidated on every request
// https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config
export const revalidate = 0;

// Initially this was a route which was just downloading the news
// However, since Vercel's free tier is limited to 2x crons of 10s runtime each,
// and generating one haiku takes between 5.5 and 6.5 seconds, we decided to merge the two routes
// So if time allows we will start the generation of one haiku as well

export async function GET(request: NextRequest) {
  // We protect the route to make sure that only the cron will be able to call this route
  // (Vercel adds a Bearer auth token to the request generated by crons, based on env variables)
  // see https://vercel.com/docs/cron-jobs/manage-cron-jobs#securing-cron-jobs
  const authHeader = request.headers.get("authorization");
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return new Response("Unauthorized", { status: 401 });
  }

  try {
    let t0 = performance.now();
    const date = dayjs();
    console.log(
      `Cron job started at ${date.format("YYYY-MM-DD HH:mm:ss")} - News Download`,
    );
    const newsList = await getNews();
    let t1 = performance.now();
    console.log(
      `News download + write in Cron job finished in ${t1 - t0} milliseconds`,
    );

    if (t1 - t0 < 2500) {
      console.log(`We still have time to generate one haiku!`);
      await generateOneHaikuFromDate(date.toDate());

      return NextResponse.json(
        {
          status: "Success",
          date: date.format("YYYY-MM-DD HH:mm:ss"),
          message: `Downloaded ${newsList.length} news articles and generated one haiku!`,
        },
        { status: 200 },
      );
    }

    return NextResponse.json(
      {
        status: "Success",
        date: date.format("YYYY-MM-DD HH:mm:ss"),
        message: `Downloaded ${newsList.length} news articles`,
      },
      { status: 200 },
    );
  } catch (e) {
    let err = e as Error;
    return NextResponse.json({ error: err.message }, { status: 500 });
  }
}
